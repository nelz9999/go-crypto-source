A Tale of Two "rand"s
Making math/rand and crypto/rand play nice together

Tags: rand, math, crypto

Nelz Carpentier

Internal Tools Team, Cloudflare
nelz@cloudflare.com

https://github.com/nelz9999/go-crypto-source/

* Let's look at math/rand (alias `mrand`)

* Pros

- fairly friendly API
- useful right out of the box

    func Float32() float32
    func Float64() float64
    func Int() int
    func Int31() int32
    func Int31n(n int32) int32
    func Int63() int64
    func Int63n(n int64) int64
    func Intn(n int) int
    func Read(p []byte) (n int, err error)
    func Uint32() uint32
    func Uint64() uint64

    func ExpFloat64() float64
    func NormFloat64() float64

    func Perm(n int) []int


* Cons

- maybe not as "random" as you'd assume
- gotta read the fine print

Overview -

  Top-level functions, such as Float64 and Int, use a default shared Source
  that produces a deterministic sequence of values each time a program is run.
  Use the Seed function to initialize the default Source if different behavior
  is required for each run.

Examples -

  Typically a non-fixed seed should be used, such as time.Now().UnixNano().
  Using a fixed seed will produce the same output on every run.

* Deterministic Random

.code adventures_test.go /START EXAMPLE01/,/END EXAMPLE01/

The individual results in each sequence of events is "random" to the
viewer, but each sequence of events is deterministic/replicable. (You would
get the same results as me, here!)

.code adventures_test.go /START OUTPUT01/,/END OUTPUT01/


* Seeded Deterministic Random

.code adventures_test.go /START EXAMPLE02/,/END EXAMPLE02/

Using the same timestamp gets you the exact same sequence, but a
slightly different timestamp nets a very different sequence. (You would get
the same results if you ran it at the same time I did!)

.code adventures_test.go /START OUTPUT02/,/END OUTPUT02/

* Let's look at crypto/rand (alias `crand`)

* Pros
- very small API
- crypto/rand.Reader conforms to `io.Reader`

  func Int(rand io.Reader, max *big.Int) (n *big.Int, err error)
  func Prime(rand io.Reader, bits int) (p *big.Int, err error)
  func Read(b []byte) (n int, err error)

  var Reader io.Reader

* Cons
- API not nearly as useful as "math/rand"
- how the heck do I use this? (`big.Int`...?!?)

  func Int(rand io.Reader, max *big.Int) (n *big.Int, err error)
  func Prime(rand io.Reader, bits int) (p *big.Int, err error)
  func Read(b []byte) (n int, err error)

  var Reader io.Reader

* Can we compose the two?

How do we dip the chocolate (crypto/rand) into the peanut butter (math/rand)?
(NB: [[https://www.youtube.com/watch?v=DJLDF6qZUX0]])

* Translation

As we've seen from "math/rand", you can create a (non-global)
instance of `rand.Rand` with a `rand.Source`
.code adventures.go /START REF03a/,/END REF03a/

How can we turn a slice of crypto-generated bytes into an `int64`? The answer lies in the "encoding/binary" package!
.code adventures.go /START REF03b/,/END REF03b/

* Let's generate some `int64`s!

.code adventures_test.go /START BigEndEx/,/END BigEndEx/

What do we get? (Different each time, for all of us!)
.code adventures_test.go /START BigEndOut/,/END BigEndOut/

* Seed With Crypto Random

Let's build a `rand.Source` with a completely random seed value.
.code adventures.go /START SAMPLE04/,/END SAMPLE04/

This greatly drops the likelihood that any two sources would have the same seed.

(See: [[https://en.wikipedia.org/wiki/Birthday_problem][Birthday Problem]])

* Let's See It Work
.code adventures_test.go /START EXAMPLE04/,/END EXAMPLE04/

Great!

.code adventures_test.go /START OUTPUT04/,/END OUTPUT04/

* But Can We Go Further?

* Look at the API for rand.Source and rand.Source64

    // A Source represents a source of uniformly-distributed
    // pseudo-random int64 values in the range [0, 1<<63).
    type Source interface {
            Int63() int64
            Seed(seed int64)
    }

Okay... That makes sense.

    // A Source64 is a Source that can also generate uniformly-distributed
    // pseudo-random uint64 values in the range [0, 1<<64) directly. If a
    // Rand r's underlying Source s implements Source64, then r.Uint64 returns
    // the result of one call to s.Uint64 instead of making two calls to s.Int63.
    type Source64 interface {
            Source
            Uint64() uint64
    }

And this looks do-able too!

* MySource

Ingore `Seed(...)`, our implementation will ALWAYS be random.
.code adventures.go /START MYSOURCESEED/,/END MYSOURCESEED/

`Uint64()` is easy!

.code adventures.go /START MYSOURCE64/,/END MYSOURCE64/

In that same vein, `Int63` is pretty easy too. Just gotta shave off one bit!
.code adventures.go /START MYSOURCE63/,/END MYSOURCE63/

* Let's see it work

.code adventures_test.go /START MYEXAMPLE/,/END MYEXAMPLE/

Each of these sequences will be different on EVERY run!
.code adventures_test.go /START MYOUTPUT/,/END MYOUTPUT/

* How does it compare?

Let's try some benchmarking
.code adventures_test.go /START BENCHa/,/END BENCHa/

Results - 40x SLOWER?!?
.code adventures_test.go /START BENCHOUTa/,/END BENCHOUTa/

* But why?
Is it something about `crypto/rand` itself?
.code adventures_test.go /START BENCHb/,/END BENCHb/

Results - `crypto/rand` is a bunch slower, in comparison
.code adventures_test.go /START BENCHOUTb/,/END BENCHOUTb/

* Summary

We _can_ use `math/rand` as the API for `crypto/rand`
- Interfaces are _AWESOME_

Non-deterministic random is a tradeoff
- Know your use case!
- This technique may not be appropriate for you if your use of random is on the hot path.

* Thank You!

Available at [[https://github.com/nelz9999/go-crypto-source/]]:
- Slides
- Source code
- A more polished API
